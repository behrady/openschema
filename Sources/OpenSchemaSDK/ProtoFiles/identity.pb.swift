// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: identity.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2016-present, Facebook, Inc.
// All rights reserved.
//
// This source code is licensed under the BSD-style license found in the
// LICENSE file in the root directory of this source tree. An additional grant
// of patent rights can be found in the PATENTS file in the same directory.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Magma_Orc8r_Identity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NOTE: Every Value type below should have corresponding entry in
  /// identityTypeNameTable in magma/protos/identity_helper.go
  public var value: Magma_Orc8r_Identity.OneOf_Value? = nil

  public var gateway: Magma_Orc8r_Identity.Gateway {
    get {
      if case .gateway(let v)? = value {return v}
      return Magma_Orc8r_Identity.Gateway()
    }
    set {value = .gateway(newValue)}
  }

  /// unique operator ID (user name), encoded in CN of operator certificate
  public var `operator`: String {
    get {
      if case .operator(let v)? = value {return v}
      return String()
    }
    set {value = .operator(newValue)}
  }

  /// unique network ID, used by REST access control
  public var network: String {
    get {
      if case .network(let v)? = value {return v}
      return String()
    }
    set {value = .network(newValue)}
  }

  public var wildcard: Magma_Orc8r_Identity.Wildcard {
    get {
      if case .wildcard(let v)? = value {return v}
      return Magma_Orc8r_Identity.Wildcard()
    }
    set {value = .wildcard(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// NOTE: Every Value type below should have corresponding entry in
  /// identityTypeNameTable in magma/protos/identity_helper.go
  public enum OneOf_Value: Equatable {
    case gateway(Magma_Orc8r_Identity.Gateway)
    /// unique operator ID (user name), encoded in CN of operator certificate
    case `operator`(String)
    /// unique network ID, used by REST access control
    case network(String)
    case wildcard(Magma_Orc8r_Identity.Wildcard)

  #if !swift(>=4.1)
    public static func ==(lhs: Magma_Orc8r_Identity.OneOf_Value, rhs: Magma_Orc8r_Identity.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.gateway(let l), .gateway(let r)): return l == r
      case (.operator(let l), .operator(let r)): return l == r
      case (.network(let l), .network(let r)): return l == r
      case (.wildcard(let l), .wildcard(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public struct Wildcard {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: Magma_Orc8r_Identity.Wildcard.TypeEnum = .gateway

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TypeEnum: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case gateway // = 0
      case `operator` // = 1
      case network // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .gateway
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .gateway
        case 1: self = .operator
        case 2: self = .network
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .gateway: return 0
        case .operator: return 1
        case .network: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct Gateway {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// unique hardware ID of a gateway encoded in CN of GW certificate
    public var hardwareID: String = String()

    public var networkID: String = String()

    public var logicalID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identities list wrapper
  public struct List {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Magma_Orc8r_Identity] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Magma_Orc8r_Identity.Wildcard.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Magma_Orc8r_Identity.Wildcard.TypeEnum] = [
    .gateway,
    .operator,
    .network,
  ]
}

#endif  // swift(>=4.2)

/// --------------------------------------------------------------------------
/// AccessGatewayID uniquely identifies an access gateway across the system
/// Based on the usage context it could represent either hardware or logical
/// AG ID.
/// --------------------------------------------------------------------------
public struct Magma_Orc8r_AccessGatewayID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "magma.orc8r"

extension Magma_Orc8r_Identity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Identity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gateway"),
    2: .same(proto: "operator"),
    3: .same(proto: "network"),
    11: .same(proto: "wildcard"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Magma_Orc8r_Identity.Gateway?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .gateway(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .gateway(v)}
      case 2:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.value = .operator(v)}
      case 3:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.value = .network(v)}
      case 11:
        var v: Magma_Orc8r_Identity.Wildcard?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .wildcard(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .wildcard(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.value {
    case .gateway(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .operator(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case .network(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    case .wildcard(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Magma_Orc8r_Identity, rhs: Magma_Orc8r_Identity) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Magma_Orc8r_Identity.Wildcard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Magma_Orc8r_Identity.protoMessageName + ".Wildcard"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .gateway {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Magma_Orc8r_Identity.Wildcard, rhs: Magma_Orc8r_Identity.Wildcard) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Magma_Orc8r_Identity.Wildcard.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Gateway"),
    1: .same(proto: "Operator"),
    2: .same(proto: "Network"),
  ]
}

extension Magma_Orc8r_Identity.Gateway: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Magma_Orc8r_Identity.protoMessageName + ".Gateway"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hardware_id"),
    2: .standard(proto: "network_id"),
    3: .standard(proto: "logical_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.hardwareID)
      case 2: try decoder.decodeSingularStringField(value: &self.networkID)
      case 3: try decoder.decodeSingularStringField(value: &self.logicalID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hardwareID.isEmpty {
      try visitor.visitSingularStringField(value: self.hardwareID, fieldNumber: 1)
    }
    if !self.networkID.isEmpty {
      try visitor.visitSingularStringField(value: self.networkID, fieldNumber: 2)
    }
    if !self.logicalID.isEmpty {
      try visitor.visitSingularStringField(value: self.logicalID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Magma_Orc8r_Identity.Gateway, rhs: Magma_Orc8r_Identity.Gateway) -> Bool {
    if lhs.hardwareID != rhs.hardwareID {return false}
    if lhs.networkID != rhs.networkID {return false}
    if lhs.logicalID != rhs.logicalID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Magma_Orc8r_Identity.List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Magma_Orc8r_Identity.protoMessageName + ".List"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.list)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Magma_Orc8r_Identity.List, rhs: Magma_Orc8r_Identity.List) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Magma_Orc8r_AccessGatewayID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessGatewayID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Magma_Orc8r_AccessGatewayID, rhs: Magma_Orc8r_AccessGatewayID) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
